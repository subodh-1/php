<?php 
/**
 * This file is just for listing the patterns in PHP
 * This is not executable file
 * 
 * Creational Patterns:
  *     Singleton Pattern: 
  *     Factory Pattern: 
  *     Abstract Factory Pattern: 
  *     Builder Pattern: 
  *     Prototype Pattern: 

 * Structural Patterns
  *     Adapter Pattern:
  *     Decorator Pattern: 
  *     Facade Pattern: 
  *     Proxy Pattern: 
  *     Composite Pattern: 

 * Behavioral Patterns
  *     Observer Pattern: 
  *     Strategy Pattern: 
  *     Command Pattern:
  *     Iterator Pattern: 
  *     State Pattern: 
  *     Template Method Pattern: 
  *     Chain of Responsibility Pattern:  
**
 * In PHP, design patterns are general reusable solutions to common problems in software design. They represent best practices and provide a way to create more maintainable and scalable code. Here are some commonly used design patterns in PHP:

 * Singleton Pattern:
        * Ensures a class has only one instance and provides a global point to access it.

 * Factory Pattern:
 *      Defines an interface for creating an object but leaves the choice of its type to the subclasses, creating the object without specifying its exact class.
 * 
 * Abstract Factory Pattern:
 *      Provides an interface for creating families of related or dependent objects without specifying their concrete classes.
 * 
 * Builder Pattern:
 *      Separates the construction of a complex object from its representation, allowing the same construction process to create different representations.
 * 
 * Prototype Pattern:
 *      Creates new objects by copying an existing object, known as the prototype.
 * 
 * Adapter Pattern:
 *      Allows the interface of an existing class to be used as another interface.
 * 
 * Decorator Pattern:
 *      Attaches additional responsibilities to an object dynamically, providing a flexible alternative to subclassing for extending functionality.
 * 
 * Observer Pattern:
 *      Defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.
 * 
 * Strategy Pattern:
 *      Defines a family of algorithms, encapsulates each one, and makes them interchangeable. Strategy lets the algorithm vary independently from the clients that use it.
 * 
 * Command Pattern:
 *      Encapsulates a request as an object, thereby allowing for parameterization of clients with different requests, queuing of requests, and logging of the parameters of the request.
 * 
 * Chain of Responsibility Pattern:
 *      Passes the request along a chain of handlers. Upon receiving a request, each handler decides either to process the request or to pass it to the next handler in the chain.
 * 
 * Template Method Pattern:
 *       Defines the skeleton of an algorithm in the superclass but lets subclasses alter specific steps of the algorithm without changing its structure.
 * 
 * Iterator Pattern:
 *      Provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation.
 * 
 * Composite Pattern:
 *      Composes objects into tree structures to represent part-whole hierarchies. It lets clients treat individual objects and compositions of objects uniformly.
 * 
 * State Pattern:
 *      Allows an object to alter its behavior when its internal state changes. The object will appear to change its class.
 */